#!/usr/bin/env python3

import os
import sys
try:
    import distro
except ImportError:
    import platform
import string
import random
from enum import Enum
import subprocess
import argparse
import textwrap
from pprint import pprint as pp
import datetime
import urllib.request
import json
from collections import namedtuple
# import IPython


class FakeColor:
    class Fore:
        BLACK = ''
        GREEN = ''
        LIGHTCYAN_EX = ''
        LIGHTRED_EX = ''
        MAGENTA = ''
        WHITE = ''
        BLUE = ''
        LIGHTBLACK_EX = ''
        LIGHTGREEN_EX = ''
        LIGHTWHITE_EX = ''
        RED = ''
        YELLOW = ''
        CYAN = ''
        LIGHTBLUE_EX = ''
        LIGHTMAGENTA_EX = ''
        LIGHTYELLOW_EX = ''
        RESET = ''

    class Back:
        BLACK = ''
        GREEN = ''
        LIGHTCYAN_EX = ''
        LIGHTRED_EX = ''
        MAGENTA = ''
        WHITE = ''
        BLUE = ''
        LIGHTBLACK_EX = ''
        LIGHTGREEN_EX = ''
        LIGHTWHITE_EX = ''
        RED = ''
        YELLOW = ''
        CYAN = ''
        LIGHTBLUE_EX = ''
        LIGHTMAGENTA_EX = ''
        LIGHTYELLOW_EX = ''
        RESET = ''

    class Style:
        BRIGHT = ''
        DIM = ''
        NORMAL = ''
        RESET_ALL = ''
        RESET = ''


APTUPDATED = False

try:
    import colorama as c
except ImportError:
    sys.stdout.write('Installing colorama... ')
    sys.stdout.flush()
    try:
        cmd = '''sudo apt-get --quiet update && sudo apt-get --quiet --yes \
                 install python3-colorama'''

        subprocess.call(cmd, shell=True, executable='/bin/bash',
                        stdout=subprocess.PIPE)
        import colorama as c
        APTUPDATED = True
    except ImportError:
        c = FakeColor()
        sys.stdout.write('Could not install colorama\n\n')
    except subprocess.CalledProcessError:
        sys.stdout.write('Could not install colorama\n\n')
    sys.stdout.write('Done\n\n')
    sys.stdout.flush()

try:
    CONSOLE_WIDTH = os.get_terminal_size().columns
except OSError:
    CONSOLE_WIDTH = 80


def display_cmd(cmd, indent=0, wrap=True, script=False):
    indent = ' ' * indent
    leader = '+ '
    initial_indent = indent + leader
    subsequent_indent = indent + (' ' * len(leader))
    if script:
        leader = ''
        initial_indent = ''
        subsequent_indent = '  '
        global CONSOLE_WIDTH
        CONSOLE_WIDTH = 80
        wrap = False if '<<' in cmd else True
    if wrap:
        w = textwrap.TextWrapper(
            initial_indent=initial_indent,
            subsequent_indent=subsequent_indent,
            break_on_hyphens=False,
            break_long_words=False,
            width=(CONSOLE_WIDTH - len(subsequent_indent))
        )
        lines = w.wrap('{}'.format(cmd))
        # Add a space & backslash to the end of each line then remove it from
        # the end of the joined string.
        fancy = '\n'.join(['{} \\'.format(i) for i in lines])[:-2]
    else:
        cmd = cmd.split('\n')
        first = [initial_indent + cmd[0]]
        rest = [i for i in cmd[1:]]
        fancy = '\n'.join(first + rest)

    if not script:
        sys.stdout.write(c.Fore.YELLOW + fancy + c.Style.RESET_ALL + '\n')
    else:
        sys.stdout.write(fancy + '\n')
    sys.stdout.flush()

def title(msg, script=False, show_date=True):
    timestamp = ''
    if show_date:
        timestamp = ' [{}]'.format(datetime.datetime.now().isoformat())
    if script:
        global CONSOLE_WIDTH
        CONSOLE_WIDTH = 80
        msg = '# {} '.format(msg).ljust(CONSOLE_WIDTH, '-')
    else:
        msg = '{}{} '.format(msg, timestamp).ljust(CONSOLE_WIDTH, '-')
    print()
    if not script:
        sys.stdout.write(c.Style.BRIGHT + c.Fore.YELLOW + msg + c.Style.RESET_ALL + '\n')
    else:
        sys.stdout.write(msg + '\n')
    sys.stdout.flush()


def warn(msg, script=False):
    if script:
        sys.stdout.write('# !!! WARNING: {} !!!\n'.format(msg))
    else:
        sys.stdout.write(c.Fore.YELLOW + c.Style.BRIGHT + 'WARNING: ' + c.Style.RESET_ALL +
                         c.Fore.YELLOW + str(msg) + c.Style.RESET_ALL + '\n')
    sys.stdout.flush()


def notify(msg):
    sys.stdout.write(c.Fore.BLUE + c.Style.BRIGHT + 'NOTICE: ' + c.Style.RESET_ALL +
                     c.Fore.BLUE + str(msg) + c.Style.RESET_ALL + '\n')
    sys.stdout.flush()


def error(msg, dry_run=False):
    sys.stdout.write(c.Fore.RED + c.Style.BRIGHT + 'ERROR: ' + c.Style.RESET_ALL +
                     c.Fore.RED + str(msg) + c.Style.RESET_ALL + '\n')
    sys.stdout.flush()
    if not dry_run:
        sys.exit(1)


def password_gen(level='alpha-num', length=10):
    levels = {
        'alpha-lower': string.ascii_lowercase,
        'alpha-mixed': string.ascii_letters,
        'alpha-num': string.ascii_letters + string.digits,
        'alpha-num-symbol': string.ascii_letters + string.digits + string.punctuation
    }
    try:
        source = levels[level]
    except KeyError:
        error('password level not one of: {}'.format(', '.join(levels.keys())))
    return ''.join(random.choices(source, k=length))


class Dist:
    """Test whether the current distro meets certain version requirments.

    d = Dist()
    d == Dist.UBUNTU
    d == (Dist.UBUNTU, Dist.V16_10)
    d > (Dist.UBUNTU, Dist.V16_10)
    """
    UBUNTU = 'Ubuntu'
    V14_04 = 14.04
    V16_04 = 16.04
    V18_04 = 18.04

    REDHAT = 'Redhat'
    CENTOS = 'CentOS'
    V4 = 4
    V5 = 5
    V6 = 6
    V7 = 7

    def __init__(self):
        try:
            self.name = distro.name()
            self.version = distro.version()
        except NameError:
            self.name = platform.dist()[0]
            self.version = platform.dist()[1]

    def __str__(self):
        return '{name} {version}'.format(**self.__dict__)

    def __eq__(self, other):
        """Comparison can be done with the distro name or the distro name and version.

        d = Distro()
        d == Distro.UBUNTU
        d == (Distro.UBUNTU, Distro.V16_04)"""
        if len(other) == 2:
            return self.name == other[0] and float(self.version) == float(other[1])
        else:
            return self.name == other

    def __ne__(self, other):
        return self.name != other[0] or float(self.version) != float(other[1])

    def __lt__(self, other):
        return self.name == other[0] and float(self.version) < float(other[1])

    def __le__(self, other):
        return self.name == other[0] and float(self.version) <= float(other[1])

    def __gt__(self, other):
        return self.name == other[0] and float(self.version) > float(other[1])

    def __ge__(self, other):
        return self.name == other[0] and float(self.version) >= float(other[1])


class Apt(Enum):
    INSTALL = 1
    UNINSTALL = 2


class DependencyError(Exception): pass
class PlatformError(Exception): pass
class SecurityError(Exception): pass

info = []

class Bash:
    def __init__(self, dry_run=False, args=None):
        self.ok_code = 0
        self.requires = []
        self.apt_pkgs = []
        self.provides = []
        self.distro = Dist()
        self.is_installed = False
        self.dry_run = dry_run
        self.args = args
        self.scriptname = os.path.basename(__file__)
        if args and not dry_run:
            action = args.subparser_name
            self.log(action, self.__class__.__name__)

    def log(self, action, name):
        log_name = '~/boss-installed-modules'
        mod = '{}\n'.format(name)
        try:
            with open(os.path.expanduser(log_name), 'r') as f:
                installed_mods = f.readlines()
        except FileNotFoundError:
            installed_mods = []

        installed_mods = set(installed_mods)
        if action == 'install':
            installed_mods.add(mod)
        elif action == 'uninstall':
            try:
                installed_mods.remove(mod)
            except KeyError:
                pass

        with open(os.path.expanduser(log_name), 'w') as f:
            f.writelines(installed_mods)

    def sed(self, sed_exp, config_file):
        now = datetime.datetime.now().strftime('%y-%m-%d-%X')
        new_ext = '.original-{}'.format(now)
        sed_cmd = 'sudo sed --in-place="{}" "{}" "{}"'.format(new_ext, sed_exp, config_file)
        self.run(sed_cmd)

    def apt(self, progs):
        self._apt(Apt.INSTALL, progs)

    def install(self):
        self._apt(Apt.INSTALL, self.apt_pkgs)
        return True

    def pre_install(self):
        return True

    def post_install(self):
        return True

    def uninstall(self):
        if self._apt(Apt.UNINSTALL, self.apt_pkgs):
            self.run('sudo apt-get --yes --quiet autoremove')
        return True

    def post_uninstall(self):
        return True

    def check_requirments(self, installed):
        missing = []
        for required in self.requires:
            if required.lower() not in installed:
                missing.append(required)
        if missing:
            raise DependencyError('Module {} requires: {}.'.format(
                self.__class__.__name__, ', '.join(missing)))

    def run(self, cmd, wrap=True, capture=False):
        if wrap:
            pretty_cmd = ' '.join(cmd.split())
            display_cmd(pretty_cmd, wrap=True, script=self.args.generate_script)
        else:
            display_cmd(cmd, wrap=False, script=self.args.generate_script)

        if self.args.dry_run or self.args.generate_script:
            return
        if capture:
            # result = subprocess.run(cmd, shell=True, check=True, executable='/bin/bash', stdout=subprocess.PIPE)
            result = subprocess.check_output(cmd, shell=True, executable='/bin/bash')
            sys.stdout.flush()
        else:
            # result = subprocess.run(cmd, shell=True, check=True, executable='/bin/bash')
            result = subprocess.check_call(cmd, shell=True, executable='/bin/bash')
        return result

    def curl(self, url, output, capture=False):
        cmd = 'curl -sSL {url} --output {output}'.format(
            url=url, output=output)
        result = self.run(cmd, capture=capture)
        return result

    def _apt(self, action, packages):
        dry = '--dry-run' if self.dry_run else ''
        packages = ' '.join(packages)
        if not packages:
            return False
        global APTUPDATED
        if not APTUPDATED:
            self.run('sudo apt-get --quiet update')
            self.run('sudo apt-get --quiet --yes upgrade')
            APTUPDATED = True
        action = 'install' if action == Apt.INSTALL else 'purge'
        self.run('export DEBIAN_FRONTEND=noninteractive; sudo apt-get {dry} --yes --quiet {action} {packages}'.format(
            action=action, dry=dry, packages=packages))
        self.is_installed = True
        return True

    def info(self, title, msg):
        info.append([title, msg])


# ------------------------------ Modules ------------------------------
class First(Bash):
    """Misc apps that are useful

    The timezone is set to America/Los_Angeles and Emacs is configured
    as the defalt editor.
    """

    def __init__(self, *args, **kwargs):
        super().__init__(*args, **kwargs)
        self.provides = ['first']
        if self.distro > (Dist.UBUNTU, Dist.V14_04):
            self.apt_pkgs = [
                'tree', 'elinks', 'virt-what', 'silversearcher-ag', 'unzip',
                'htop', 'source-highlight', 'whois', 'curl', 'figlet', 'ntp',
            ]
        elif self.distro == (Dist.UBUNTU, Dist.V14_04):
            self.apt_pkgs = [
                'tree', 'elinks', 'virt-what', 'silversearcher-ag', 'unzip',
                'htop', 'source-highlight', 'whois', 'curl', 'figlet'
            ]
        # self.apt_pkgs += ['joe']
        self.apt_pkgs += ['emacs-nox'] # adds aprox 100mb

    def pre_install(self):
        pass

    def post_install(self):
        # set timezone
        tz = 'America/Los_Angeles'
        self.run('sudo timedatectl set-timezone {}'.format(tz))

        # configure the editor
        # editor = 'jmacs'
        editor = 'emacs'
        cmds = [
            "echo export EDITOR='{}' >> $HOME/.bashrc".format(editor),
            "echo export VISUAL='{}' >> $HOME/.bashrc".format(editor),
            "echo export SUDO_EDITOR='{}' >> $HOME/.bashrc".format(editor),
        ]
        if editor == 'jmacs':
            cmds += ["echo alias emacs='jmacs' >> $HOME/.bashrc"]
        for cmd in cmds:
            self.run(cmd)


class Cert(Bash):
    """A self signed cert good for 30 years

    It's name is the servername, SERVERNAME.crt and SERVERNAME.key.
    They are install in /etc/ssl."""

    def __init__(self, *args, **kwargs):
        super().__init__(*args, **kwargs)
        self.provides = ['cert']

    def cert_names(self, cert_basename):
        crt = '{}.crt'.format(cert_basename)
        key = '{}.key'.format(cert_basename)

        home_crt = os.path.join(os.path.expanduser('~'), crt)
        home_key = os.path.join(os.path.expanduser('~'), key)

        cert_loc = '/etc/ssl'
        real_crt = os.path.join(cert_loc, 'certs', crt)
        real_key = os.path.join(cert_loc, 'private', key)

        return home_crt, home_key, real_crt, real_key

    def pre_install(self):
        cert_basename = self.args.servername
        self.run('''
            sudo openssl \
                 req \
                 -new \
                 -newkey rsa:4096 \
                 -days 10950 \
                 -nodes \
                 -x509 \
                 -subj "/C=US/ST=Denial/L=Springfield/O=Dis/CN={servername}" \
                 -keyout {cert_basename}.key \
                 -out {cert_basename}.crt &>/dev/null
        '''.format(
            servername=self.args.servername,
            cert_basename=cert_basename
        ))
        self.run('sudo cp {cert_basename}.crt /etc/ssl/certs/{cert_basename}.crt'.format(
            cert_basename=cert_basename))
        self.run('sudo cp {cert_basename}.key /etc/ssl/private/{cert_basename}.key'.format(
            cert_basename=cert_basename))

    def post_uninstall(self):
        cert_basename = self.args.cert_basename
        home_crt, home_key, real_crt, real_key = self.cert_names(cert_basename)

        self.run('[[ -e {f} ]] && sudo rm {f}'.format(f=home_crt))
        self.run('[[ -e {f} ]] && sudo rm {f}'.format(f=home_key))
        self.run('sudo test -e {f} && sudo rm {f}'.format(f=real_crt))
        self.run('sudo test -e {f} && sudo rm {f}'.format(f=real_key))


class Apache2(Bash):
    """Stand alone Apache

    With a default site at /var/www/html.
    """

    def __init__(self, *args, **kwargs):
        super().__init__(*args, **kwargs)
        self.provides = ['apache2']
        self.apt_pkgs = ['apache2']

    def post_uninstall(self):
        self.run('if sudo test -d /etc/apache2; then sudo rm -rf /etc/apache2; fi')


class Nginx(Bash):
    def __init__(self, *args, **kwargs):
        super().__init__(*args, **kwargs)
        self.provides = ['nginx']
        self.apt_pkgs = ['nginx']


class Php(Bash):
    """Base PHP, nothing else."""
    def __init__(self, *args, **kwargs):
        super().__init__(*args, **kwargs)
        self.provides = ['php']
        self.requires = ['apache2']
        if self.distro > (Dist.UBUNTU, Dist.V14_04):
            self.apt_pkgs = ['php']
        elif self.distro == (Dist.UBUNTU, Dist.V14_04):
            self.apt_pkgs = ['php5']


class PhpInfo(Bash):
    """Create a phpinfo.php file in /var/www/html

    It is available at https://<servername>/phpinfo.php"""

    def __init__(self, *args, **kwargs):
        super().__init__(*args, **kwargs)
        self.provides = ['phpinfo']
        self.requires = ['php']
        self.loc = '/var/www/html'
        self.info_file = '{}/phpinfo.php'.format(self.loc)

    def post_install(self):
        info = '<h1>{}</h1>\n<?php phpinfo();'.format(datetime.datetime.now().isoformat())
        if os.path.exists(self.loc):
            cmd = 'echo \'{info}\' | sudo -u www-data tee {loc}'.format(
                info=info,
                loc=self.info_file
            )
            self.run(cmd)
        else:
            error('[PhpInfo] Dir does not exist: {}'.format(self.loc), self.args.dry_run)

        self.info('Php info', 'https://{}/phpinfo.php'.format(self.args.servername))

    def post_uninstall(self):
        cmd = 'if test -e {infofile}; then rm {infofile}; fi'.format(
            infofile=self.info_file
        )
        self.run(cmd)


class Mysql(Bash):
    """Mysql db and password configuration

    Requires root's password and new db to create.  Optionally, a new
    user can be created.

    root's password: --db-root-password=PASSWORD
    New db: --db-name=DBNAME
    Optional new user and password: --new-db-user-and-pass=USER,PASSWORD
    """

    def __init__(self, *args, **kwargs):
        super().__init__(*args, **kwargs)
        self.provides = ['mysql']
        self.apt_pkgs = ['mysql-server']

    def configure_root_password(self):
        root_pass = self.args.db_root_pass
        self.run('''sudo debconf-set-selections <<< \
            "mysql-server mysql-server/root_password password {}"'''.format(root_pass))
        self.run('''sudo debconf-set-selections <<< \
            "mysql-server mysql-server/root_password_again password {}"'''.format(root_pass))

    def setup_user(self, db_user, db_pass, root_pass):
        # only for MySQL 5.7.8 and up?
        sql = '''
        DROP USER IF EXISTS '{db_user}'@'localhost';
          CREATE USER '{db_user}'@'localhost'
            IDENTIFIED BY '{db_pass}';
          GRANT ALL PRIVILEGES ON * . * TO '{db_user}'@'localhost';
          FLUSH PRIVILEGES;
        '''.format(
            db_user=db_user,
            db_pass=db_pass
        )
        self.run('mysql -uroot -p{root_pass} <<EOF\n{sql}\nEOF'.format(
            root_pass=root_pass,
            sql=sql), wrap=False)

    def create_schema(self, db_name, root_pass):
        sql = ' '.join('''
          DROP DATABASE IF EXISTS {db_name};
          CREATE DATABASE IF NOT EXISTS {db_name};
        '''.format(
            db_name=db_name,
        ).split())
        self.run('mysql -uroot -p{root_pass} <<EOF\n{sql}\nEOF'.format(
            root_pass=root_pass,
            sql=sql
        ), wrap=False)

    def import_sql(self, root_pass, sql_file):
        self.run('mysql -uroot -p{root_pass} < {sql_file}'.format(
            root_pass=root_pass,
            sql_file=sql_file
        ))

    def pre_install(self):
        self.configure_root_password()

    def post_install(self):
        if self.args.new_db_user_and_pass:
            db_user, db_pass = self.args.new_db_user_and_pass
            self.setup_user(db_user, db_pass, self.args.db_root_pass)
        if self.args.db_name:
            self.create_schema(self.args.db_name, self.args.db_root_pass)
        if self.args.sql_file:
            self.import_sql(self.args.db_root_pass, self.args.sql_file)


class Composer(Bash):
    """If the distro is older than 18.04 composer is installed from source
    from github.  Otherwise it is installed from the apt repo.
    """

    def __init__(self, *args, **kwargs):
        super().__init__(*args, **kwargs)
        self.provides = ['composer']
        self.requires = ['php']

    def post_install(self):
        if self.distro < (Dist.UBUNTU, Dist.V18_04):
            self.source_install()
        else:
            self.apt_install()

        # add www-data to the ubuntu group so when running composer as
        # www-data user, it can create a cache in ubuntu's home dir.
        self.run('sudo usermod -aG $USER www-data')
        self.run('sudo chown -R $USER: $HOME/.composer')
        self.run('sudo chmod -R uga+rw $HOME/.composer')

    def apt_install(self):
        self.apt(['composer'])

    def source_install(self):
        url = 'https://composer.github.io/installer.sig'
        sig_name = os.path.expanduser('~/composer.sig')
        self.curl(url, sig_name)

        expected_sig = None
        if os.path.exists(sig_name):  # could be a dry run
            with open(os.path.expanduser(sig_name)) as f:
                expected_sig = f.read()
            expected_sig = expected_sig.strip()
            self.run('rm {}'.format(sig_name))

        url = 'https://getcomposer.org/installer'
        comp_name = '$HOME/composer_installer'
        self.curl(url, comp_name)

        actual_sig = None
        result = self.run('sha384sum {}'.format(comp_name), capture=True)
        if result:  # could be a dry run
            actual_sig = result.decode('utf-8').split()[0].strip()

        if expected_sig != actual_sig:
            raise SecurityError('Composer\'s signatures do not match.\nExpected: "{}"\n  Actual: "{}"'.format(
                expected_sig, actual_sig
            ))

        [self.run(command) for command in (
            # 'php {} --quiet'.format(comp_name),
            'sudo php {} --quiet --install-dir=/usr/local/bin --filename=composer'.format(comp_name),
            # 'rm {}'.format(comp_name),
            # 'sudo mv composer.phar /usr/local/bin/composer',
            # 'if [[ ! -e $HOME/.composer ]]; then mkdir $HOME/.composer/; fi',
            # 'chmod a+rw $HOME/.composer/',
        )]

    def post_uninstall(self):
        self.run('sudo rm /usr/local/bin/composer')
        self.run('if [[ -e $HOME/.composer ]]; then rm -rf $HOME/.composer/; fi')
        self.run('if [[ -e $HOME/composer.sig]]; then rm $HOME/composer.sig; fi')


class Xdebug(Bash):
    def __init__(self, *args, **kwargs):
        super().__init__(*args, **kwargs)
        self.provides = ['xdebug']
        self.requires = ['php']
        self.apt_pkgs = ['php-xdebug']    # good enough?


class PhpMyAdmin(Bash):
    """Web database client

    Access at http://<servername>/phpmyadmin
    Use the root username and the password specified via --db_root_pass
    """

    def __init__(self, *args, **kwargs):
        super().__init__(*args, **kwargs)
        self.provides = ['phpmyadmin']
        self.requires = ['apache2', 'php', 'mysql']
        self.apt_pkgs = ['phpmyadmin']

    def pre_install(self):
        root_pass = self.args.db_root_pass
        self.run('sudo debconf-set-selections <<< "phpmyadmin phpmyadmin/reconfigure-webserver multiselect apache2"')
        self.run('sudo debconf-set-selections <<< "phpmyadmin phpmyadmin/dbconfig-install boolean true"')
        self.run('sudo debconf-set-selections <<< "phpmyadmin phpmyadmin/app-password-confirm password {}"'.format(root_pass))
        self.run('sudo debconf-set-selections <<< "phpmyadmin phpmyadmin/reconfigure-webserver multiselect none"')

        self.run('sudo debconf-set-selections <<< "phpmyadmin phpmyadmin/mysql/admin-user string root"')
        self.run('sudo debconf-set-selections <<< "phpmyadmin phpmyadmin/mysql/admin-pass password {}"'.format(root_pass))
        self.run('sudo debconf-set-selections <<< "phpmyadmin phpmyadmin/mysql/app-pass password {}"'.format(root_pass))

    def post_install(self):
        self.info('PhpMyadmin', 'https://{}/phpmyadmin'.format(self.args.servername))


class Craft2(Bash):
    def __init__(self, *args, **kwargs):
        super().__init__(*args, **kwargs)
        self.provides = ['craft2']
        self.requires = ['apache2', 'php', 'mysql']
        if self.distro > (Dist.UBUNTU, Dist.V14_04):
            self.apt_pkgs = ['php-mbstring', 'php-imagick', 'php-mcrypt', 'php-curl',
                             'php-xml', 'php-zip', 'php-gd', 'php-mysql']
        elif self.distro == (Dist.UBUNTU, Dist.V14_04):
            self.apt_pkgs = ['php5', 'php5-imagick', 'php5-mcrypt', 'php5-curl',
                             'php5-gd', 'php5-mysql' , 'libapache2-mod-php5']


class Craft3(Bash):
    """https://craftcms.com"""

    def __init__(self, *args, **kwargs):
        super().__init__(*args, **kwargs)
        self.provides = ['craft3']
        self.requires = ['apache2', 'php', 'mysql', 'composer']
        if self.distro == (Dist.UBUNTU, Dist.V16_04):
            self.apt_pkgs = ['php-mbstring', 'php-imagick', 'php-mcrypt',
                             'php-curl', 'php-xml', 'php-zip']
        elif self.distro >= (Dist.UBUNTU, Dist.V18_04):
            self.apt_pkgs = ['php7.2-mbstring', 'php-imagick', 'php7.2-curl',
                             'php-xml', 'php7.2-zip']
        else:
            raise PlatformError("Platform is not Ubuntu 16.04 or 18.04.  Don't know which php extra packages to install for Craft3")
        self.craft_dir = '/var/www/craft'
        self.html_dir = '/var/www/html'

    def post_install(self):
        # setup the dirs
        craft_dir = self.craft_dir
        html_dir = self.html_dir
        for d in (craft_dir, html_dir):
            if not os.path.exists(d):
                self.run('sudo mkdir {}'.format(d))
            self.run('sudo chown www-data: {}'.format(d))
            self.run('sudo chmod ug+rw {}'.format(d))

        # make sure craft dir is empty
        if not self.args.dry_run:
            if os.listdir(craft_dir):
                error('Craft dir is not empty. ({})'.format(craft_dir), self.args.dry_run)

        # Install craft3 via composer
        craft_db_user = 'root'
        craft_db_pass = self.args.db_root_pass
        craft_db_name = self.args.db_name

        # install from composer
        self.run('sudo -u www-data composer create-project --no-ansi --remove-vcs --no-interaction craftcms/craft {}'.format(craft_dir))

        # setup the db
        self.run('''sudo -u www-data php {craft_dir}/craft setup/db --interactive 0 \
            --driver mysql \
            --database {db_name} \
            --user {db_user} \
            --password {db_pass} \
            --port 3306 \
            --server localhost'''.format(
                craft_dir=craft_dir,
                db_name=craft_db_name,
                db_user=craft_db_user,
                db_pass=craft_db_pass
            ))
        # run the install
        username, email, password = self.args.craft_credentials
        self.run('''sudo -u www-data php {craft_dir}/craft install/craft --interactive=0 \
            --email={email} \
            --username={username} \
            --password={password} \
            --siteName={sitename} \
            --siteUrl={siteurl}'''.format(
                craft_dir=craft_dir,
                email=email,
                username=username,
                password=password,
                sitename=self.args.servername,
                siteurl="'@web'"
            ))

        # copy web files to the html dir, adjust permissions, enable rewrite and restart server
        [self.run(command) for command in (
            'sudo chown www-data: {}'.format(html_dir),
            'sudo -u www-data cp -r "{}/web/." "{}"'.format(craft_dir, html_dir),
            'sudo chmod 774 {}/cpresources/'.format(html_dir),
            'sudo chmod -R g+rw {}'.format(craft_dir),
            'sudo chmod -R g+rw {}'.format(html_dir),
            'sudo a2enmod rewrite',
            'sudo service apache2 restart',
        )]

        sed_exp = 's|dirname(__DIR__)|\'{}\'|'.format(craft_dir)
        index = os.path.join(html_dir, 'index.php')
        self.sed(sed_exp, index)
        self.run('sudo chown www-data:www-data {}'.format(index))

        self.info('Craft admin', 'https://{}/admin'.format(self.args.servername))

    def post_uninstall(self):
        self.run('sudo rm -rf {}'.format(self.craft_dir))
        for f in ['cpresources', '.htaccess', 'index.php', 'web.config']:
            # self.run('rm -rf {}/{}'.format(self.html_dir, f))
            warn('{} should be removed also'.format(f))


class VirtualHost(Bash):
    """Create virtualhost configuration files for http and https"""

    def __init__(self, *args, **kwargs):
        super().__init__(*args, **kwargs)
        self.provides = ['virtualhost']
        self.requires = ['apache2', 'cert']

    def _http(self, servername, document_root):
        https_redirect = '# Redirect permanent "/" https://{servername}/'.format(
            servername=servername
        )
        vhost = '''
            # HTTP
            <VirtualHost *:80>
                ServerAdmin webmaster@localhost

                ServerName {servername}
                {https_redirect}
                DocumentRoot /var/www/{document_root}
                <Directory "/var/www">
                    AllowOverride All
                </Directory>

                # ErrorLog ${{APACHE_LOG_DIR}}/error.log
                # CustomLog ${{APACHE_LOG_DIR}}/access.log combined
            </VirtualHost>'''.format(
            servername=servername,
            document_root=document_root,
            https_redirect=https_redirect
        )
        vhost = '\n'.join([i[12:] for i in vhost.split('\n')])
        return vhost

    def _https(self, servername, document_root, cert, key):
        vhost = '''

            # HTTPS
            <VirtualHost *:443>
                ServerAdmin webmaster@localhost

                ServerName {servername}
                # ServerAlias www.{servername}

                DocumentRoot /var/www/{document_root}
                <Directory "/var/www">
                    AllowOverride All
                </Directory>

                # ErrorLog ${{APACHE_LOG_DIR}}/error.log
                # CustomLog ${{APACHE_LOG_DIR}}/access.log combined

                SSLEngine on
                SSLOptions +StrictRequire
                SSLCertificateFile {cert}
                SSLCertificateKeyFile {key}
            </VirtualHost>'''.format(
            servername=servername,
            document_root=document_root,
            cert=cert,
            key=key
        )
        vhost = '\n'.join([i[12:] for i in vhost.split('\n')])
        return vhost

    def existing_cert(self, servername):
        # retrieve the existing cert for servername
        cert = Cert()
        _, _, crt, key = cert.cert_names(servername)
        return (crt, key)

    def new_cert(self, site_name):
        # create a new cert using this site's site_name
        CertArgs = namedtuple('CertArgs', 'servername dry_run')
        cert_args = CertArgs(site_name, self.args.dry_run)
        cert = Cert(dry_run=self.args.dry_run, args=cert_args)
        cert.pre_install()
        _, _, crt, key = cert.cert_names(site_name)
        return (crt, key)

    def create_doc_root(self, document_root):
        # make www-root owner of the doc root
        doc_root = '/var/www/{}'.format(document_root)
        self.run('sudo mkdir {}'.format(doc_root))
        self.run('sudo chown www-data:www-data {}'.format(doc_root))

    def post_install(self):
        mods = ['ssl', 'rewrite']
        for m in mods:
            self.run('sudo a2enmod {}'.format(m))

        for site in self.args.site_name_and_root:
            site_name = site[0]
            document_root = site[1]
            vhost_config = self._http(site_name, document_root)

            crt, key = self.existing_cert(self.args.servername)
            # crt, key = self.new_cert(site_name)
            vhost_config += self._https(site_name, document_root, crt, key)

            conf_file = '/etc/apache2/sites-available/{}.conf'.format(site_name)

            sites_available = '/etc/apache2/sites-available'
            self.run('echo | sudo tee {conf} <<EOF\n{file}\nEOF'.format(
                sites=sites_available,
                conf=conf_file,
                file=vhost_config
            ), wrap=False)

            # self.create_doc_root(document_root)

            # enable this site
            self.run('sudo a2ensite {}'.format(site_name))
            self.info('Website', 'https://{}'.format(site_name))
            self.info(' └─ Apache conf', conf_file)

        # restart apache
        self.run('sudo service apache2 restart')

    def post_uninstall(self):
        # delete conf file
        # delete doc root
        # remove cert
        pass


class Wordpress(Bash):
    def __init__(self, *args, **kwargs):
        super().__init__(*args, **kwargs)
        self.provides = ['wordpress']


class WpCli(Bash):
    """The wordpress cli application"""
    def __init__(self, *args, **kwargs):
        super().__init__(*args, **kwargs)
        self.provides = ['wpcli']


class NewUser(Bash):
    """Create a new user

    Create a new user and add them to the sudo and www-data groups.
    The new user does not require a password for sudo."""

    def __init__(self, *args, **kwargs):
        super().__init__(*args, **kwargs)
        self.provides = ['newuser']
        self.requires = ['first']

    def pre_install(self):
        username, password = self.args.new_system_user_and_pass

        self.run('if ! id -u {username} &>/dev/null; then sudo useradd --shell=/bin/bash --create-home --password \
                  $(mkpasswd -m sha-512 {password}) {username}; fi'.format(
            password=password, username=username
        ))
        self.run('### or if using these commands interactively, use:')
        self.run('# adduser {username}...'.format(username=username, password=password))
        # add user to some groups
        for group in ('sudo', 'www-data'):
            self.run('sudo usermod -aG {group} {username}'.format(
                group=group,
                username=username
            ))
        # make user not need a password for sudo
        sudo_file = '/etc/sudoers.d/{}-{}'.format(self.scriptname, username)  # filename cannot have a . or ~
        self.run("echo '{} ALL=(ALL) NOPASSWD:ALL' | sudo tee {}".format(username, sudo_file))

    def uninstall(self):
        username = self.args.system_user
        self.run('sudo userdel -r {}'.format(username))
        sudo_file = '/etc/sudoers.d/{}-{}'.format(self.scriptname, username)
        self.run('sudo rm {}'.format(sudo_file))


class Bashrc(Bash):
    """A custom bashrc from GitHub and symlink boss to ~/bin/

    1. Downloads a bashrc from GitHub and creates a bin dir in the $HOME dir.
    2. Backups the orginal .bashrc
    3. Symlinks the ~/bin/bashrc to ~/.bashrc
    4. Symlink /project/boss to ~/bin/boss"""

    def __init__(self, *args, **kwargs):
        super().__init__(*args, **kwargs)
        self.provides = ['bashrc']
        self.apt_pkgs = ['emacs-nox']

    def install_bashrc(self):
        self.run('if [[ ! -d $HOME/bin ]]; then mkdir $HOME/bin; fi')
        gh_files = {
            'bashrc': 'https://raw.githubusercontent.com/8cylinder/bin/master/bashrc',
            'bashrc_prompt.py': 'https://raw.githubusercontent.com/8cylinder/bin/master/bashrc_prompt.py',
            'bashrc_prompt.themes': 'https://raw.githubusercontent.com/8cylinder/bin/master/bashrc_prompt.themes',
        }
        for ghname, ghurl in gh_files.items():
            self.curl(ghurl, '$HOME/bin/' + ghname)

        # if .bashrc is not a link, back it up
        self.run('if [[ ! -L $HOME/.bashrc ]]; then mv $HOME/.bashrc $HOME/.bashrc.original; fi')
        # if .bashrc does not exist, make a link to bin/bashrc
        self.run('if [[ ! -e $HOME/.bashrc ]]; then ln -s $HOME/bin/bashrc $HOME/.bashrc; fi')
        # self.run('echo -e "\n\nalias emacs=\'jmacs\'\n" >> $HOME/bin/bashrc')
        self.run('chmod +x $HOME/bin/bashrc_prompt.py')

    def link_boss(self):
        source = __file__
        name = os.path.basename(source)
        dest = os.path.expanduser(os.path.join('$HOME/bin', name))
        self.run('if [[ ! -h {} ]]; then ln -s {} {}; fi'.format(dest, source, dest))

    def post_install(self):
        self.install_bashrc()
        self.link_boss()

    def uninstall(self):
        self.run('if [[ -d $HOME/bin ]]; then sudo rm -rf $HOME/bin; fi')
        # if .bashrc.original exists, restore it
        self.run('if [[ -e $HOME/.bashrc.original ]]; then mv .bashrc.original .bashrc; fi')


class AptProxy(Bash):
    """Use the host machine's apt proxy

    apt-cacher-ng needs to be installed and configured on the host:
    1. sudo apt install apt-cacher-ng
    2. echo 'Acquire::http::Proxy "http://<HOST IP>:3142";' | sudo tee /etc/apt/apt.conf.d/00aptproxy

    Installation can be checked by going to http://<HOST IP>:3142/acng-report.html

    Then when using the `aptproxy` module, it will create a config
    file in apt.conf.d to configure apt to use the host's apt cache by
    running the following command:
    `echo 'Acquire::http::Proxy "http://<HOST IP>:3142";' | sudo tee /etc/apt/apt.conf.d/00aptproxy`"""

    conf_file = '/etc/apt/apt.conf.d/00aptproxy'

    def __init__(self, *args, **kwargs):
        super().__init__(*args, **kwargs)
        self.provides = ['aptproxy']

    def post_install(self):
        host_ip = self.args.host_ip
        proxy_setting = '\'Acquire::http::Proxy "http://{}:3142";\''.format(host_ip)
        cmd = 'echo {setting} | sudo tee {ip}'.format(
            setting=proxy_setting,
            ip=self.conf_file
        )
        self.run(cmd)

    def post_uninstall(self):
        cmd = 'sudo rm {}'.format(self.conf_file)
        self.run(cmd)


class Webmin(Bash):
    def __init__(self, *args, **kwargs):
        super().__init__(*args, **kwargs)
        self.provides = ['webmin']
        self.requires = ['apache2', 'php', 'cert']
        self.apt_pkgs = ['webmin']

    def pre_install(self):
        # add webmin to sources.list, get PGP key
        cmds = [
            'sudo cp /etc/apt/sources.list /etc/apt/sources.list.bak',
            'echo "deb http://download.webmin.com/download/repository sarge contrib" | sudo tee -a /etc/apt/sources.list',
            # 'wget http://www.webmin.com/jcameron-key.asc',
            # 'sudo apt-key add jcameron-key.asc',
        ]
        self.curl('http://www.webmin.com/jcameron-key.asc', 'jcameron-key.asc')
        self.run('sudo apt-key add jcameron-key.asc')
        for cmd in cmds:
            global APTUPDATED
            APTUPDATED = False
            self.run(cmd)

        self.info('Webmin', 'http://{}:10000 (user & password for any user that can sudo)'.format(self.args.servername))

    def post_install(self):
        pass


class Netdata(Bash):
    """Netdata server monitoring"""
    # https://github.com/firehol/netdata
    # https://github.com/firehol/netdata/wiki/Running-behind-apache
    # https://www.digitalocean.com/community/tutorials/how-to-set-up-real-time-performance-monitoring-with-netdata-on-ubuntu-16-04
    # args: username (default:netdata), password (default:<random>)

    def __init__(self, *args, **kwargs):
        super().__init__(*args, **kwargs)
        self.provides = ['netdata']
        self.requires = ['apache2']
        if self.distro >= (Dist.UBUNTU, Dist.V18_04):
            self.apt_pkgs = ['netdata']
        else:
            warn('Netdata only available on Ubuntu 18.04 or greater')

        # manual install: bash <(curl -Ss https://my-netdata.io/kickstart.sh) --non-interactive all

    def post_install(self):
        if self.distro >= (Dist.UBUNTU, Dist.V18_04):
            self.sed('s/bind socket to IP = .*$/bind socket to IP = *.*.*.*/', '/etc/netdata/netdata.conf')
            self.run('sudo systemctl restart netdata')
            self.info('Netdata', 'http://{}:19999'.format(self.args.servername))



class Lamp(Apache2, Mysql):
    """The whole shebang

    This runs `apt-get install lamp-server^`

    Installed packages.  Use `apt show lamp-server^ | grep Package:` for
    details.

    perl, apache2, apache2-bin, apache2-utils, apache2-data, ssl-cert,
    php7.0-cli, php7.0-common, php7.0-json, php7.0-opcache,
    mysql-common, perl-modules-5.22, tcpd, mysql-client-5.7,
    mysql-client-core-5.7, mysql-server, mysql-server-5.7,
    mysql-server-core-5.7, rename, php-common, php-mysql,
    php7.0-mysql, php7.0-readline"""

    def __init__(self, *args, **kwargs):
        super().__init__(*args, **kwargs)
        self.provides = ['apache2', 'php', 'mysql', 'lamp']
        self.apt_pkgs = ['lamp-server^']

    def pre_install(self):
        for cls in Lamp.__bases__:
            cls.pre_install(self)

    def post_install(self):
        for cls in Lamp.__bases__:
            cls.post_install(self)

        self.run('sudo service apache2 restart')

    def post_uninstall(self):
        for cls in Lamp.__bases__:
            cls.post_uninstall(self)


class FakeSMTP(Bash):
    """A fake SMTP server for mail testing

    https://www.lullabot.com/articles/installing-mailhog-for-ubuntu-1604
    """
    def __init__(self, *args, **kwargs):
        super().__init__(*args, **kwargs)
        self.provides = ['fakesmtp']
        self.requires = ['php']
        if self.distro == (Dist.UBUNTU, Dist.V14_04):
            self.phpini = '/etc/php5/apache2/php.ini'
            self.cliini = '/etc/php5/cli/php.ini'
        elif self.distro == (Dist.UBUNTU, Dist.V16_04):
            self.phpini = '/etc/php/7.0/apache2/php.ini'
            self.cliini = '/etc/php/7.0/cli/php.ini'
        elif self.distro >= (Dist.UBUNTU, Dist.V18_04):
            self.phpini = '/etc/php/7.2/apache2/php.ini'
            self.cliini = '/etc/php/7.2/cli/php.ini'
        else:
            error('FakeSMTP: no php.ini defined')

    def post_install(self):
        self.install_via_github()
        sedcmd = 's|;sendmail_path =|sendmail_path = /usr/local/bin/mhsendmail|'
        cmds = [
            'chmod +x mailhog mhsendmail',
            'sudo mv mailhog mhsendmail /usr/local/bin',
        ]
        [self.run(i) for i in cmds]
        self.sed(sedcmd, self.phpini)
        self.sed(sedcmd, self.cliini)

        if self.distro == (Dist.UBUNTU, Dist.V14_04):
            self.config_upstart()
        elif self.distro >= (Dist.UBUNTU, Dist.V16_04):
            self.config_systemd()

        self.info('FakeSMTP client', 'http://{}:8025'.format(self.args.servername))
        self.info(' └─ FakeSMTP api', 'curl http://{}:8025/api/v2/messages'.format(self.args.servername))

    def install_via_go(self):
        pass

    def install_via_github(self):
        # download mailhog & mhsendmail.  Get the latest release using
        # GitHub's api.
        data = [{
            'release': 'MailHog_linux_amd64',
            'localname': 'mailhog',
            'url': 'https://api.github.com/repos/mailhog/MailHog/releases/latest',
        }, {
            'release': 'mhsendmail_linux_amd64',
            'localname': 'mhsendmail',
            'url': 'https://api.github.com/repos/mailhog/mhsendmail/releases/latest',
        }]
        # Sometimes github returns 'forbidden' when accessing the api.
        # Rate limiting maybe? I don't know.
        try:
            for prog in data:
                r = urllib.request.urlopen(prog['url']).read()
                content = json.loads(r.decode('utf-8'))
                for asset in content['assets']:
                    if asset['name'] == prog['release']:
                        self.curl(asset['browser_download_url'], prog['localname'])
        except urllib.error.HTTPError as e:
            error('MAILHOG github api: {}'.format(e.msg))

    def config_upstart(self):
        # 14.04 uses upstart
        service = '''
            description "Mailhog"
            start on runlevel [2345]
            stop on runlevel [!2345]
            exec /usr/bin/env /usr/local/bin/mailhog > /dev/null 2>&1 &
        '''
        service_file = '/etc/init/mailhog.conf'
        service = '\n'.join([i[12:] for i in service.split('\n')])
        self.run('echo | sudo tee {service_file} <<EOF{contents}EOF'.format(
            service_file=service_file,
            contents=service
        ), wrap=False)

        self.run('sudo ln -s {} /etc/init.d/mailhog'.format(service_file))
        self.run('sudo service mailhog start')

    def config_systemd(self):
        # 16.04 + uses systemd
        service = '''
            [Unit]
            Description=MailHog service

            [Service]
            ExecStart=/usr/local/bin/mailhog \\\\
              -api-bind-addr 0.0.0.0:8025 \\\\
              -ui-bind-addr 0.0.0.0:8025 \\\\
              -smtp-bind-addr 0.0.0.0:1025

            [Install]
            WantedBy=multi-user.target
        '''
        service_file = '/etc/systemd/system/mailhog.service'

        service = '\n'.join([i[12:] for i in service.split('\n')])
        self.run('echo | sudo tee {service_file} <<EOF{contents}EOF'.format(
            service_file=service_file,
            contents=service
        ), wrap=False)
        self.run('sudo systemctl start mailhog')
        self.run('sudo systemctl enable mailhog')

    def post_uninstall(self):
        if self.distro == (Dist.UBUNTU, Dist.V14_04):
            # self.run('sudo service mailhog stop')
            self.run('sudo rm /etc/init/mailhog.conf')
            self.run('sudo rm /etc/init.d/mailhog')
        elif self.distro >= (Dist.UBUNTU, Dist.V16_04):
            self.run('sudo systemctl disable mailhog')
            self.run('sudo rm /etc/systemd/system/mailhog.service')

        self.run('sudo rm /usr/local/bin/mailhog /usr/local/bin/mhsendmail')
        sed_exp = 's|sendmail_path = /usr/local/bin/mhsendmail|;sendmail_path =|'
        self.sed(sed_exp, self.phpini)
        self.sed(sed_exp, self.cliini)


class Done(Bash):
    def __init__(self, *args, **kwargs):
        super().__init__(*args, **kwargs)
        self.provides = ['done']

    def pre_install(self):
        self.run('figlet -k -w89 {}'.format(self.args.servername))
        for title, msg in info:
            if self.args.generate_script:
                sys.stdout.write("echo '{:20} {}'\n".format(title + ':', msg))
            else:
                sys.stdout.write('{:30} {}'.format(
                    c.Style.BRIGHT + c.Fore.WHITE + title + ':' + c.Style.RESET_ALL,
                    c.Fore.BLUE + msg + c.Style.RESET_ALL + '\n'
                ))
            sys.stdout.flush()
        sys.stdout.write('\n')


# --------------------------------- UI ---------------------------------

def init(args):
    # list of all modules and the order they should be executed in.
    mappings = [
        ('aptproxy', AptProxy),
        ('first', First),  # this is a required module
        ('newuser', NewUser),
        ('cert', Cert),
        ('lamp', Lamp),
        ('apache2', Apache2),
        ('nginx', Nginx),
        ('php', Php),
        ('phpinfo', PhpInfo),
        ('mysql', Mysql),
        ('composer', Composer),
        ('xdebug', Xdebug),
        ('phpmyadmin', PhpMyAdmin),
        ('craft2', Craft2),
        ('craft3', Craft3),
        ('fakesmtp', FakeSMTP),
        ('newsite', VirtualHost),
        ('wpcli', WpCli),
        ('netdata', Netdata),
        ('webmin', Webmin),
        ('bashrc', Bashrc),
        ('done', Done),
    ]
    if args.subparser_name == 'install':
        install_uninstall(args, mappings)
    elif args.subparser_name == 'uninstall':
        install_uninstall(args, mappings)
    elif args.subparser_name == 'list':
        list_modules(args, mappings)
    elif args.subparser_name == 'help':
        found = False
        w = textwrap.TextWrapper(initial_indent='', subsequent_indent='  ', break_on_hyphens=False)
        for mapping in mappings:
            if args.module.lower() in mapping[0].lower() or args.module == 'all':
                app = mapping[1]()
                print()
                title(app.__class__.__name__, show_date=False)
                if app.__doc__:
                    lines = app.__doc__.split('\n')
                    lines = [i.strip() for i in lines]
                    print('\n'.join(lines))
                else:
                    print('(No documentation)')
                if app.apt_pkgs:
                    print()
                    # print('Installed apt packages:', end=' ')
                    installed = w.wrap('Installed packages: {}'.format(', '.join(app.apt_pkgs)))
                    print('\n'.join(installed))
                if app.requires:
                    print()
                    print('Requires: {}'.format(', '.join(app.requires)))

                found = True
        if not found:
            error('Unknown module: {}.  Try `boss list`'.format(args.module))


def list_modules(args, mappings):
    installed_file = os.path.expanduser('~/boss-installed-modules')
    installed = []
    if os.path.exists(installed_file):
        with open(installed_file) as f:
            installed = f.readlines()
        installed = [i.lower().strip() for i in installed]

    for row in mappings:
        name = row[0]
        module = row[1]
        # state = '[X] ' if name in installed else '[-] '
        state = ' ✓ ' if name in installed else '   '
        state = c.Fore.GREEN + state + c.Style.RESET_ALL
        description = module.__doc__ if module.__doc__ else ''
        description = description.split('\n')[0]
        modline = state + c.Style.BRIGHT + name.ljust(12) + c.Style.RESET_ALL + description + '\n'
        sys.stdout.write(modline)
        sys.stdout.flush()


def install_uninstall(args, mappings):
    modules = args.modules

    required = ['first', 'done']
    # extract the requested modules and the required from mappings
    if args.subparser_name == 'install':
        if args.no_required:
            apps = [i for i in mappings if i[0] in modules]
        else:
            apps = [i for i in mappings if i[0] in modules or i[0] in required]
    else:
        apps = [i for i in mappings if i[0] in modules]

    # check if the user is asking for non-existent modules
    mapping_keys = [i[0] for i in mappings]
    invalid_modules = [i for i in modules if i not in mapping_keys]
    if invalid_modules:
        error('module(s) "{invalid}" does not exist.\nValid modules are:\n{valid}'.format(
            valid=', '.join(mapping_keys),
            invalid=', '.join(invalid_modules)
        ))

    # check if the requested modules have their dependencies met
    if args.subparser_name == 'install' and not args.no_dependencies:
        install_reqs = []
        for mapping in apps:
            app = mapping[1]()
            install_reqs += app.provides
            provided = set(install_reqs)
            required = set(app.requires)
            # print(provided, required)
            if len(required - provided):
                error('Requirements not met for {}: {}.'.format(
                    app.__class__.__name__, ', '.join(app.requires)))

    if args.generate_script:
        sys.stdout.write('#!/usr/bin/env bash\n\n')
        sys.stdout.write('# {}\n\n'.format(' '.join(sys.argv)))
        sys.stdout.write('PS4=\'+ ${LINENO}: \'\n')
        sys.stdout.write('set -x\n')

    user = None
    installed = []
    for mapping in apps:
        App = mapping[1]
        module_name = App.__name__
        title(module_name, script=args.generate_script)
        # module_title = '{} '.format(module_name)
        # title(module_title.ljust(CONSOLE_WIDTH, '-'))
        app = App(dry_run=args.dry_run, args=args)

        # if mapping == 'newuser':
        #     # set the user after 'newuser' has run so the rest of the modules
        #     # will use the new user.
        #     user, _ = self.args.new_system_user_and_pass

        try:
            if args.subparser_name == 'install':
                if not args.no_dependencies:
                    app.check_requirments(installed)
                app.pre_install()
                app.install()
                app.post_install()
                installed += app.provides
                app.log('install', module_name)
            elif args.subparser_name == 'uninstall':
                app.uninstall()
                app.post_uninstall()
                app.log('uninstall', module_name)
        except subprocess.CalledProcessError as e:
            error(e)
        except DependencyError as e:
            error(e)
        except PlatformError as e:
            error(e)
        except SecurityError as e:
            error(e)


if __name__ == '__main__':
    # custom types for argparse
    def userpass(s):
        try:
            username, password = [i.strip() for i in s.split(',', 1) if i.strip()]
        except ValueError:
            msg = '''must be a username and password seperated by a comma
            (the password can have a comma in it, but not the username).'''
            raise argparse.ArgumentTypeError(msg)
        return username.strip(), password.strip()

    def userpassemail(s):
        try:
            username, email, password = [i.strip() for i in s.split(',', 2) if i.strip()]
        except ValueError:
            msg = '''must be a username, email and password seperated by a comma
            (the password can have a comma in it, but not the username or email).'''
            raise argparse.ArgumentTypeError(msg)
        return username.strip(), email.strip(), password.strip()

    def newsite(s):
        sites = s.split(':')
        cleaned_sites = []
        for site in sites:
            try:
                sitename, documentroot = [i.strip() for i in site.split(',', 1) if i.strip()]
            except ValueError:
                msg = 'must be a sitename and document root seperated by a comma.'
                raise argparse.ArgumentTypeError(msg)
            if '/' in documentroot:
                raise argparse.ArgumentTypeError('DOCUMENTROOT cannot have a "/" in it.')
            cleaned_sites.append((sitename, documentroot))
        return cleaned_sites

    def file_exists(s):
        if not os.path.exists(s):
            msg = 'file must exist.'
            raise argparse.ArgumentTypeError(msg)
        else:
            return s

    def url(s):
        if '.' not in s:
            msg = 'the servername must have a "." in it, eg. something.local'
            raise argparse.ArgumentTypeError(msg)
        else:
            return s

    # help_msg = 'Install various aplications and miscellany to set up a server.'
    help_msg = textwrap.dedent('''
    Install various applications and miscellany to set up a server.

    This can be run standalone or as a Vagrant provider.  When run as
    a vagrant provider its recommended that is be run unprivileged.
    This will run as the default user and the script will use sudo
    when necessary (this assumes the default user can use sudo).  This
    means that any subsequent uses as the default user will be able to
    update the '$HOME/boss-installed-modules' file.  Also if the
    bashrc module is installed during provisioning, then the correct
    home dir will be setup.

    eg:
    config.vm.provision :shell,
                        path: 'boss',
                        args: 'install server.local ...'

    Its recommended to set up Apt-Cacher NG on the host machine.  Once
    that's done adding `aptproxy` to the list of modules will configure
    this server to make use of it.

    boss will attempt to install colorama when it's run.  If for some
    reason that doesn't work, it can be manually installed by:
    `sudo apt install python3-colorama`''')

    epilog_msg = 'https://www.github.com/8cylinder/sink'

    parser = argparse.ArgumentParser(
        description=help_msg, epilog=epilog_msg,
        formatter_class=argparse.RawDescriptionHelpFormatter)
    subparsers = parser.add_subparsers(dest='subparser_name')

    ## INSTALL ##
    ins = subparsers.add_parser('install', help='Install modules')
    ins.add_argument('servername', type=url,
                     help="used for the cert name and apache ServerName, eg: 'something.local'")
    ins.add_argument('modules', nargs='+',
                     help='a list of modules that should be installed')

    ins.add_argument('-d', '--dry-run', action='store_true',
                     help='Only print the commands that would be used')
    ins.add_argument('-o', '--no-required', action='store_true',
                     help="Don't install the required modules")
    ins.add_argument('-O', '--no-dependencies', action='store_true',
                     help="Don't install dependent modules")
    ins.add_argument('--generate-script', action='store_true',
                     help='Output suitable for a bash script instead of running them')
    # unix user
    ins.add_argument('-n', '--new-user-and-pass', type=userpass, metavar='USERNAME,USERPASS',
                     help="a new unix user's name and password (seperated by a comma), they will be added to the www-data group")
    # mysql
    ins.add_argument('-S', '--sql-file', type=file_exists, metavar='SQLFILE',
                     help='sql file to be run during install')
    ins.add_argument('-N', '--db-name', metavar='DB-NAME',
                     required='mysql' in sys.argv or 'lamp' in sys.argv or 'craft3' in sys.argv,
                     help="the name the schema to create")
    ins.add_argument('-P', '--db-root-pass', metavar='PASSWORD',
                     required='mysql' in sys.argv or 'lamp' in sys.argv or 'craft3' in sys.argv or 'phpmyadmin' in sys.argv,
                     help='password for mysql root user, required for the mysql module')
    ins.add_argument('-A', '--new-db-user-and-pass', type=userpass, metavar='USERNAME,PASSWORD',
                     help="a new db user's new username and password (seperated by a comma)")
    # new user
    ins.add_argument('-u', '--new-system-user-and-pass', type=userpass, metavar='USERNAME,PASSWORD',
                     required='newuser' in sys.argv,
                     help="a new system user's new username and password (seperated by a comma)")
    # newsite
    ins.add_argument('-s', '--site-name-and-root', type=newsite, metavar='SITENAME,DOCUMENTROOT[:...]',
                    required='newsite' in sys.argv,
                     help='''SITENAME and DOCUMENTROOT seperated by a comma (doc root will be put in /var/www).
                       Multiple sites can be specified by seperating them with a ":", eg: -s site1,root1:site2,root2''')
    # craft 3
    ins.add_argument('-c', '--craft-credentials', type=userpassemail, metavar='USERNAME,EMAIL,PASSWORD',
                     required='craft3' in sys.argv,
                     help='Craft admin credentials')
    # aptproxy
    ins.add_argument('-i', '--host-ip',
                     required='aptproxy' in sys.argv,
                     help='Host ip to be used in aptproxy config')
    # netdata
    ins.add_argument('--netdata-user-pass', type=userpass, metavar='USERNAME,USERPASS',
                     help="a new user's name and password (seperated by a comma)")

    ## UNINSTALL ##
    uni = subparsers.add_parser('uninstall', help='Uninstall modules')
    uni.add_argument('modules', nargs='+',
                     help='a list of modules that should be uninstalled')
    uni.add_argument('-d', '--dry-run', action='store_true',
                     help='run apt but use `apt-get --simulate` (non apt shell commands will still execute)')
    uni.add_argument('-D', '--very-dry-run', action='store_true',
                     help='do not run any shell commands')
    uni.add_argument('-c', '--cert-basename', required='cert' in sys.argv,
                     help='basename of the cert to be removed, should be the same as servername')
    uni.add_argument('-u', '--system-user', required='newuser' in sys.argv,
                     help='name of the user to be deleted (note: all files will be deleted as well)')

    ## LIST ##
    lst = subparsers.add_parser('list', help='List available modules')

    ## HELP ##
    hlp = subparsers.add_parser('help', help='Detailed info for each module')
    hlp.add_argument('module', nargs='?', default='all',
                     help='The name of the module that you want more info about')

    args = parser.parse_args()
    try:
        init(args)
    except KeyboardInterrupt:
        print('\nQuiting.')
        sys.exit(1)
